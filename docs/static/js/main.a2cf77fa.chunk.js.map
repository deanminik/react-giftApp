{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setinputValue","onSubmit","e","preventDefault","console","log","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","imgs","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","setTimeout","useFetchGifs","img","key","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"6MASaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAAmB,EAMRC,mBAAS,IAND,mBAMrCC,EANqC,KAMzBC,EANyB,KA6B5C,OAgBI,0BAAMC,SA7BW,SAACC,GAElBA,EAAEC,iBACAC,QAAQC,IAAI,gBAGVN,EAAWO,OAAOC,OAAO,IACzBV,GAAc,SAAAW,GAAI,OAAKT,GAAL,mBAAmBS,OACrCR,EAAc,mBAsBb,4BAAKD,GACF,2BAEHU,KAAK,OACLC,MAAOX,EACPY,SAzCiB,SAACT,GACjBE,QAAQC,IAAIH,EAAEU,OAAOF,OAErBV,EAAcE,EAAEU,OAAOF,Y,uBCnBxBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DACbC,EADa,iDACoCC,UAAUH,GAD9C,+DAEAI,MAAMF,GAFN,cAEbG,EAFa,gBAIIA,EAAKC,OAJT,uBAIXC,EAJW,EAIXA,KAEFC,EAAOD,EAAKE,KAAI,SAAAC,GAAS,IAAD,EAC1B,MAAO,CACHC,GAAID,EAAKC,GACTC,MAAOF,EAAKE,MACZV,IAAG,UAAEQ,EAAKG,cAAP,aAAE,EAAaC,iBAAiBZ,QAVxB,kBAaZM,GAbY,4CAAH,sDC8BPO,EAAc,SAAC,GAAuB,IAAtBJ,EAAqB,EAArBA,GAAIC,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAIpC,OAFAZ,QAAQC,IAAIoB,EAAIC,EAAOV,GAGnB,yBAAKc,UAAU,4CACX,yBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,2BAAIA,KC2RHO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECnTb,SAACA,GAAc,IAAD,EACZhB,mBAAS,CAC7BuB,KAAK,GACLa,SAAQ,IAHwB,mBAC/BC,EAD+B,KACxBC,EADwB,KAyBtC,OAlBAC,qBAAU,WACLxB,EAAQC,GACPwB,MAAM,SAAAd,GAEJe,YAAW,WACPH,EAAS,CACLf,KAAMG,EACNU,SAAQ,MAEb,UAIT,CAACpB,IAKIqB,EDgSuBK,CAAa1B,GAA/Ba,EANyB,EAM9BN,KAAYa,EANkB,EAMlBA,QAEnB,OAEI,oCACQ,wBAAIJ,UAAU,4CAA6ChB,GAE1DoB,GAAW,sCACd,yBAAKJ,UAAU,aAKGH,EAAOJ,KAAK,SAACkB,GAAD,OAEZ,kBAAC,EAAD,eACAC,IAAKD,EAAIhB,IAELgB,UE1QvBE,EAAe,WAAO,IAAD,EACM7C,mBAAS,CAAC,oBADhB,mBACvB8C,EADuB,KACX/C,EADW,KAE9B,OACI,oCACI,4CAEA,kBAAC,EAAD,CAAaA,cAAeA,IAE5B,6BACA,4BAEQ+C,EAAWrB,KAAI,SAAAT,GAAQ,OAEnB,kBAAC,EAAD,CAEI4B,IAAK5B,EACLA,SAAUA,UC3FtC+B,IAASC,OAEL,kBAAC,EAAD,MAEFC,SAASC,eAAe,U","file":"static/js/main.a2cf77fa.chunk.js","sourcesContent":["import React, { useState } from 'react'\nimport { GifExpertApp } from '../GifExpertApp';\nimport PropTypes from 'prop-types';\nimport { unmountComponentAtNode } from 'react-dom';\n\n// estos es un prop \n\n// export const AddCategory = ({prop_desestructurado}) => {\n\nexport const AddCategory = ({setCategories}) => {\n  \n        \n    // const [inputValue, setinputValue] = useState('Hola Mundo'); con un estado\n    // const [inputValue, setinputValue] = useState(); undefined \n    // string vacio \n    const [inputValue, setinputValue] = useState(''); \n    \n    \n\n    const handleInputChange = (e) =>{\n              console.log(e.target.value);\n\n              setinputValue(e.target.value)\n    }\n\n    const handleSubmit = (e) =>{\n        //  y para prevenir que la pagina no vuelva a cargar ya que es un defecto por default del formulario \n        e.preventDefault();\n          console.log('submit hecho'); \n\n        //   para borrar los espacios de antes y despues usar trim \n        if( inputValue.trim().length>2){\n            setCategories(cats => [inputValue,...cats]);\n            setinputValue('esto es otro')\n        }\n          \n    }\n    \n    return (\n        // <>\n        //    <h1>{inputValue}</h1>\n        //   <input\n             \n        //      type=\"text\"\n        //      value={inputValue} \n        //      onChange={handleInputChange}\n        //   ></input> \n        // </>\n\n        // fragament es para agrupar elementos en este caso no lo vamos a usar \n        // porque vamos a usar un form que tambien sirve como agrupador \n         \n        // para usar la tecla enter vamos a usar onsubmit \n        \n        <form onSubmit={handleSubmit}>\n             <h1>{inputValue}</h1>\n                <input\n             \n             type=\"text\"\n             value={inputValue} \n             onChange={handleInputChange}\n          ></input> \n        </form>\n    )\n}\n\n// con esto que estamos haciendo obligamos a la persona que tiene que usar nuestro componente \n// el warning sale en la consola \n\n\nAddCategory.propTypes ={\n    setCategories: PropTypes.func.isRequired\n}\n\n// entonces si alguien escribe esto \n// <AddCategory/>\n// en vez de esto le saldar error \n// <AddCategory setCategories={setCategories}/>","\n\n\nexport const getGifs = async (category) => {\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI(category)}&limit=10&api_key=pbro3Wn5yeSBQJXUThYcSymeXn1hUQvW`;\n    const resp = await fetch(url);\n\n    const { data } = await resp.json();\n\n    const gifs = data.map(imgs => {\n        return {\n            id: imgs.id,\n            title: imgs.title,\n            url: imgs.images?.downsized_medium.url\n        }\n    })\n    return gifs;\n\n\n}","import React from 'react'\n//   en el parametro recibi una umagen o un gif \n// export const GifGridItem = (img) => {\n\n//     console.log(img)\n\n//     return (\n//         <div>\n//             {img.title}\n//         </div>\n//     )\n// }\n\n\n//_________________________________________________________________\n\n// export const GifGridItem = (props) => {\n\n//     console.log(props.img)\n\n//     return (\n//         <div>\n//           \n//         </div>\n//     )\n// }\n\n\n//_____________________________________________________________-\n\n// ESta forma es mucho más facil de leer que con las props o sea propiedades\n\n//desestructuramos\nexport const GifGridItem = ({id, title, url }) => {\n\n    console.log(id, title, url);\n\n    return (\n        <div className=\"card animate__animated animate__fadeInUp\">\n            <img src={url} alt={title}/>\n            <p>{title}</p>\n        </div>\n    )\n}\n","// import React, { useEffect, useState } from 'react'\nimport React from 'react';\nimport { useFetchGifs } from '../hooks/useFetchGifs';\n// import { getGifs } from '../helpers/getGifs'\nimport { GifGridItem } from './GifGridItem';\n\n\n// export const GifGrid = ({category}) => {\n\n//     const getGifs = async() =>{\n//         const url = 'https://api.giphy.com/v1/gifs/search?q=cheeseburgers&limit=10&api_key=pbro3Wn5yeSBQJXUThYcSymeXn1hUQvW';\n//         const resp = await fetch(url);\n//         // const data = await resp.json();\n//         // Todo lo anterior es puro javascript\n//         //cupamos desestructurar lo siguien para que  sólo nos traiga las imagenes \n//         const {data} = await resp.json();\n\n//        // vamos a recorrer cada una de las imagenes/ poniendole un nombre al objeto puede ser cualquiera en este caso imgs \n//        const gifs = data.map(imgs =>{\n//            return{\n//                id: imgs.id,\n//                title: imgs.title,\n//             //    url: imgs.images.downsized_medium.url\n//             // por si no están tdas las imagenes agregar b?\n//                url: imgs.images?.downsized_medium.url\n//            }\n//        })\n\n//         // console.table(data);\n//         console.table(gifs);\n\n//     }\n\n//     getGifs();\n//     return (\n//         <>\n//             <h3>{category}</h3>\n//         </>\n//     )\n// }\n\n\n//______________________________________________________________________________-\n\n// USO DE useEffect \n\n// export const GifGrid = ({ category }) => {\n\n\n//     const [count, setCount] = useState(0);\n//     useEffect(() => {\n//         getGifs();\n//         //luego hay que enviarle un arreglo de dependecias depsues de }\n//         // es decir solo quiero que se ejecute la función cuando es ejecutado por primera ves y no lo repkita \n//     }, [])\n//     const getGifs = async () => {\n//         const url = 'https://api.giphy.com/v1/gifs/search?q=cheeseburgers&limit=10&api_key=pbro3Wn5yeSBQJXUThYcSymeXn1hUQvW';\n//         const resp = await fetch(url);\n\n//         const { data } = await resp.json();\n\n//         const gifs = data.map(imgs => {\n//             return {\n//                 id: imgs.id,\n//                 title: imgs.title,\n//                 url: imgs.images?.downsized_medium.url\n//             }\n//         })\n\n\n//         console.log(gifs);\n\n//     }\n\n//     // getGifs();\n//     return (\n//         <>\n//             <h3>{category}</h3>\n//             <h3>{count}</h3>\n//             <button onClick={()=> setCount(count + 1)}>Aumentar</button>\n//         </>\n//     )\n// }\n\n\n//__________________________________________________________________________\n\n// export const GifGrid = ({ category }) => {\n\n//     const [images, setImages] = useState([])\n    \n//     useEffect(() => {\n//         getGifs();\n//         //luego hay que enviarle un arreglo de dependecias depsues de }\n//         // es decir solo quiero que se ejecute la función cuando es ejecutado por primera ves y no lo repkita \n//     }, [])\n//     const getGifs = async () => {\n//         const url = 'https://api.giphy.com/v1/gifs/search?q=cheeseburgers&limit=10&api_key=pbro3Wn5yeSBQJXUThYcSymeXn1hUQvW';\n//         const resp = await fetch(url);\n\n//         const { data } = await resp.json();\n\n//         const gifs = data.map(imgs => {\n//             return {\n//                 id: imgs.id,\n//                 title: imgs.title,\n//                 url: imgs.images?.downsized_medium.url\n//             }\n//         })\n\n\n//         console.log(gifs);\n//         //El nuevo estado será los gifs que estoy recibiendo \n//         setImages(gifs);\n\n//     }\n\n//     // getGifs();\n//     return (\n//         <>\n//             <h3>{category}</h3>\n//              <ol>\n//                  {/* <li>item</li> */}\n//                  {/* vamos a usar una expresion de javascript, images viene de la linea 86 usando el useState  */}\n//                  {\n//                     //  cuando no tenemos las llaves estamos haciendo un return implicito \n//                     //  images.map( img =>(\n                          \n//                     //  <li key={img.id}>{img.title}</li>\n//                     //  ))\n//                       //_______________________________________\n//                      //La forma desestructurada\n//                      images.map( ({id,title}) =>(\n                          \n//                         <li key={id}>{title}</li>\n//                         ))\n//                  }\n//              </ol>\n//         </>\n//     )\n// }\n\n\n//________________________________________________________________________________________\n\n// export const GifGrid = ({ category }) => {\n\n//     const [images, setImages] = useState([])\n    \n//     useEffect(() => {\n//         getGifs();\n//         //luego hay que enviarle un arreglo de dependecias depsues de }\n//         // es decir solo quiero que se ejecute la función cuando es ejecutado por primera ves y no lo repkita \n//     }, [])\n//     const getGifs = async () => {\n//         const url = 'https://api.giphy.com/v1/gifs/search?q=cheeseburgers&limit=10&api_key=pbro3Wn5yeSBQJXUThYcSymeXn1hUQvW';\n//         const resp = await fetch(url);\n\n//         const { data } = await resp.json();\n\n//         const gifs = data.map(imgs => {\n//             return {\n//                 id: imgs.id,\n//                 title: imgs.title,\n//                 url: imgs.images?.downsized_medium.url\n//             }\n//         })\n\n\n//         console.log(gifs);\n//         //El nuevo estado será los gifs que estoy recibiendo \n//         setImages(gifs);\n\n//     }\n\n//     // getGifs();\n//     return (\n//         // usamos fraghment porque ya tenemos 2 objetos tanto el h3 como el div \n//         <>\n//         <h3>{category}</h3>\n//         <div className=\"card-grid\">\n          \n             \n                 \n//                  {\n                \n//                      images.map( (img) =>(\n//                           // neceitamos mandar la imagen \n//                         <GifGridItem \n//                         key={img.id}\n//                         // img = {img}\n//                         //usaremos el operador spread\n//                         {...img}\n//                         />\n//                         ))\n//                  }\n            \n//         </div>\n//         </>\n//     )\n// }\n\n//_________________________________________________________________________________________________________________\n\n\n// export const GifGrid = ({ category }) => {\n\n//     const [images, setImages] = useState([])\n    \n//     useEffect(() => {\n//         getGifs();\n//     }, [])\n//     const getGifs = async () => {\n//         const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI(category)}&limit=10&api_key=pbro3Wn5yeSBQJXUThYcSymeXn1hUQvW`;\n//         const resp = await fetch(url);\n\n//         const { data } = await resp.json();\n\n//         const gifs = data.map(imgs => {\n//             return {\n//                 id: imgs.id,\n//                 title: imgs.title,\n//                 url: imgs.images?.downsized_medium.url\n//             }\n//         })\n//         console.log(gifs);\n//         setImages(gifs);\n\n//     }\n\n//     return (\n\n//         <>\n//         <h3>{category}</h3>\n//         <div className=\"card-grid\">\n\n//                  {\n                \n//                      images.map( (img) =>(\n//                           // neceitamos mandar la imagen \n//                         <GifGridItem \n//                         key={img.id}\n//                         // img = {img}\n//                         //usaremos el operador spread\n//                         {...img}\n//                         />\n//                         ))\n//                  }\n            \n//         </div>\n//         </>\n//     )\n// }\n\n// ___________________________________________ \n//usando helper\n\n// export const GifGrid = ({ category }) => {\n\n//     const [images, setImages] = useState([]);\n    \n//     useEffect(() => {\n//         //lo siguiente retorna una promesa\n//         getGifs(category)\n//         // .then(imgs => setImages(imgs))\n//         //tambien es lo mismo hacerlo así\n//         .then(setImages);\n//         //tuvimos una funcion que unicamente el imgs primero es mandado a la funcion que haby dentro de setImages \n//     }, [category])\n  \n\n//     return (\n\n//         <>\n//         <h3>{category}</h3>\n//         <div className=\"card-grid\">\n\n//                  {\n                \n//                      images.map( (img) =>(\n//                           // neceitamos mandar la imagen \n//                         <GifGridItem \n//                         key={img.id}\n//                         // img = {img}\n//                         //usaremos el operador spread\n//                         {...img}\n//                         />\n//                         ))\n//                  }\n            \n//         </div>\n//         </>\n//     )\n// }\n//________________________________________________________________________\n// USO DE CUSTOM HOOK \n\n// export const GifGrid = ({ category }) => {\n\n   \n//     // const state = useFetchGifs();\n\n//     // vamos a desestructurar el state \n      \n//     const {data,loading} = useFetchGifs(category);\n//     console.log(loading);\n//     console.log(data);\n\n\n  \n\n//     return (\n\n//         <>\n//         <h3>{category}</h3>\n//         {/* // si loading esta en true ? entonces se pone Cargando...' caso contrario : Data cargada */}\n//         {loading ? 'Cargando...' : 'Data cargada'} \n//         </>\n//     )\n// }\n\n//______________________________________________________________________________\n\nexport const GifGrid = ({ category }) => {\n\n\n      \n    // const {data,loading} = useFetchGifs(category);\n    //  para que ese paramro no se llama data sino que images hay qie darle un nombre y se hace de la siguiente forma \n    const {data:images,loading} = useFetchGifs(category);\n\n    return (\n\n        <>\n                <h3 className=\"card animate__animated animate__fadeInUp\" >{category}</h3>\n                {/* si esto es true loading  enronces evalua esto <p>Loading</p>} si el primero no es true entonces no hace nada */}\n                {loading && <p>Loading</p>}\n              <div className=\"card-grid\">\n        \n                       {\n                        \n                            //  data.map( (img) =>(\n                                images.map( (img) =>(\n                           \n                                <GifGridItem \n                                key={img.id}\n                             \n                                {...img}\n                                />\n                                ))\n                         }\n                    \n                </div>\n                </>\n    )\n}","import { useEffect, useState } from \"react\"\nimport {getGifs} from '../helpers/getGifs'\n\n// ESTO ES UN CUSTOM HOOK \n\n// export const useFetchGifs = () => {\n//    const [state, setstate] = useState({\n//          data:[],\n//          loading:true\n\n//    });\n\n//    return state; // {data:[], loading: true};\n// }\n\n\nexport const useFetchGifs = (category) => {\n    const [state, setState] = useState({\n          data:[],\n          loading:true\n \n    });\n    \n    useEffect(() =>{\n         getGifs(category)\n         .then (imgs =>{\n\n            setTimeout(() => {\n                setState({\n                    data: imgs,\n                    loading:false\n                });\n            }, 3000);\n\n             \n         })\n    },[category])\n\n\n  \n \n    return state; // {data:[], loading: true};\n }\n ","import React, { useState } from 'react'\nimport { AddCategory } from './components/AddCategory';\nimport { GifGrid } from './components/GifGrid';\n\n// si pone el export aqui significa que lleva llaves en el indice a la hora de importar\n// export const GifExpertApp = () => {\n\n// const categories = ['One Punch','Samurai X','Dragon Ball'];\n// para no tener que usar ese arreglo y tras de eso no lo podemos mutar podríamos usar el siguiente hook\n// useState \n// lo importamos\n\n// usetState:  el segundo parametro es para añadir categorias setcategories\n// en este caso el arreglo sería un estado \n\n// const [categories, setCategories] = useState(['One Punch','Samurai X','Dragon Ball']);\n\n// const handleAdd = () =>{\n// si utilizan el push no sería una buena practica lo mejor sería el setCategories\n\n//  setCategories('Hunter');\n// si lo dejamos va a reventar porque está intentando cambiar las categoria entonces hay que extraerlo los elementos del arreglo \n\n\n// entonces despues de estraer las categorias con los ... 3puntos en el segundo parametro colocamos lo que queremos añadir\n// setCategories([...categories,'vengo desde un hook llamado useState que tiene un arreglo y yo soy su nuevo elemento']); \n\n// si quiere que el elemento venga de primero cambian de posicion los paramtros \n\n// setCategories(['vengo desde un hook llamado useState que tiene un arreglo y yo soy su nuevo elemento',...categories]);\n\n\n// otra forma y es muy efectiva es por medio de callback \n//cats es nuestro call back\n// setCategories(cats =>[...cats,'vengo desde un hook llamado useState que tiene un arreglo y yo soy su nuevo elemento'])  \n// } \n\n//     export const GifExpertApp = () => {\n\n//     // const [categories, setCategories] = useState(['One Punch','Samurai X','Dragon Ball']);\n//     const [categories, setCategories] = useState(['One Punch']);\n//     return (\n//         <>\n//             <h2>GifExpertApp</h2>\n//             {/* <AddCategory></AddCategory> */}\n//             {/* vamos a usar comunicacion entre los componentes  */}\n//             <AddCategory setCategories={setCategories}/>\n\n//             <hr></hr>\n\n//             {/* <button onClick={handleAdd}>Agregar un nuevo elemento</button> */}\n\n//             {/* para introducir arreglos */}\n//             <ol>\n//             {\n//                 // categories.map( seleting_category => {\n//                 //                //primer parametro el index | dentro del li lo que hay en ese index  \n//                 //                // NO SE PUEDEN REPETIR LOS KEYS SINO DA ERROR EL CONTENIDO DE CADA ESPACIO DEBE DE SER UNICOO \n//                 // return <li key={seleting_category}>{seleting_category}{' holas'}</li>\n//                 // })\n\n//                 // categories.map( seleting_category => {\n\n//                     categories.map( category => (\n\n//                                         <GifGrid\n//                                         //   key={category}\n//                                         category = {category}/> \n//                     ))\n//             }\n//             </ol>\n\n//         </>\n\n//     )\n// }\n\n\n\n//_________________________________________________________________________________________________-\n\nexport const GifExpertApp = () => {\n    const [categories, setCategories] = useState(['Hunter x Hunter']);\n    return (\n        <>\n            <h2>GifExpertApp</h2>\n\n            <AddCategory setCategories={setCategories} />\n\n            <hr />\n            <ol>\n                {\n                    categories.map(category => (\n\n                        <GifGrid\n                           // this is the unique key\n                            key={category}\n                            category={category} />\n                    ))\n                }\n            </ol>\n\n        </>\n\n    )\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport {GifExpertApp} from './GifExpertApp';\n\n\nReactDOM.render(\n  \n    <GifExpertApp />,\n\n  document.getElementById('root')\n);\n\n// Crear un componente llamado gifExpertApp\n// lo unico que va atener es un h2 que diga gif expert app \n\n"],"sourceRoot":""}